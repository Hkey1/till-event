const assert          = require('node:assert');
const NodeEvents      = require('node:events');
const ExtendedPromise = require('hkey-extended-promise'); //const ExtendedPromise  = require('../extended-promise/ExtendedPromise.js');

function tillEvent(emitters, events, opts={}){
	emitters = Array.isArray(emitters)   ? emitters       : [emitters];
    events   = Array.isArray(events)     ? events         : [events];	 
    opts     = typeof(opts)==='function' ? {filter: opts} : (
		(opts instanceof AbortController || opts instanceof AbortSignal) 
										 ? {abort: opts} : opts
	);	 
	emitters.forEach(emitter=>{
		assert(emitter!==null);
		assert.equal(typeof(emitter),'object');
		if(emitter.removeListener){
			assert.equal(typeof(emitter.removeListener),'function');
		} else {
			assert.equal(typeof(emitter.removeEventListener),'function');
		}
	});

	events.forEach(event=>{
		assert.equal(typeof(event),'string');
		assert(event.length!==0);
	});
	
	const was = {};
	events.forEach(event=>{
		if(typeof(event)!=='string'){
			throw new Error('till.events must Array of strings');
		} else if(!event.length){
			throw new Error('till.events must Array of not empty strings');
		} else if(was[event]===true){
			throw new Error('till.events must uniq Array. Repeat event='+event);
		} else was[event]=true;
	});

	if(opts.filter!==undefined && typeof(opts.filter)!=='function'){
		throw new Error('till.filter is not undefined or function typeof(opts.filter)='+typeof(opts.filter));
	}

	const funs = [];
	const promise = new ExtendedPromise({
		...opts,
		onFinish : function finish(...args){
			if(opts.onFinish){
				opts.onFinish(...args);
			}
			for(let i=0; i<emitters.length; i++){
				const curFuns = funs[i];
				const emitter = emitters[i];
				for(let eventName in curFuns){
					if(emitter.removeListener){
						emitter.removeListener(eventName, curFuns[eventName]);
					} else {
						emitter.removeEventListener(eventName, curFuns[eventName]);
					}
				}
			}
		},
	});
	const fun  = function (emitter, event, ...args){
		const result  = {emitter, event, arguments: args, args, timestamp: Date.now(), isOld: false};
		let filterRes;
		if(opts.filter){
			try{
				filterRes = opts.filter(promise, result);
			} catch(e){
				promise.reject(e);
				return;
			}
			if(filterRes===undefined || filterRes===false){
				return;
			}
			promise.resolve(filterRes);
		} else {
			promise.resolve(result);
		}
	}
	for(let i=0; i<emitters.length; i++){
		const emitter = emitters[i];
		funs[i] = {};
		events.forEach(eventName=>{
			const binded = fun.bind(emitter, emitter, eventName);
			binded._isAutoGenerated = true;
			funs[i][eventName] = binded;
			if(typeof(emitter.on)==='function'){
				emitter.on(eventName, binded);  //не once поскольку есть фильтр
			} else {
				emitter.addEventListener(eventName, binded); 
			}
		})
	}
	return promise;
}
module.exports  = tillEvent;